<h2 id="livecycles"><a href="#livecycles"></a>LiveCycles</h2>
<p>The native web component API has <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks">livecycles</a>
   methods:</p>
<ul>
	<li>connectedCallback;</li>
	<li>disconnectedCallback;</li>
	<li>attributeChangedCallback;</li>
	<li>adoptedCallback;</li>
</ul>
<p><code>WebComponent</code> simply renames them and &quot;fixes&quot; couple of things about some of them.</p>

<h3 id="onupdate"><a href="#onupdate"></a>onUpdate</h3>
<p>This livecycle function is called right after the DOM gets updated by
	<a href="https://github.com/beforesemicolon/cwco/blob/master/docs/properties.md">property</a>,
   observed <a href="https://github.com/beforesemicolon/cwco/blob/master/docs/attributes.md">attribute</a> or
	<a href="https://github.com/beforesemicolon/cwco/blob/master/docs/context.md">context</a>
   is updated.</p>
<p>Differently than the <code>attributeChangedCallback</code>, the <code>onUpdate</code> will only get called if the component is in the DOM
   and fully parsed with children rendered.</p>
<p>It will always get called with the name of the property that changed, the old and the new value as arguments except for
   context updates where new and old value are always the same for lack of context object tracking.</p>

<code-snippet language="js">
class BFSButton extends WebComponent {
	static observedAttributes = ['label']
	
	onUpdate(prop, oldValue, newValue) {
		console.log('updated', prop, oldValue, newValue)
	}
}

BFSButton.register();

</code-snippet>

<code-snippet language="js">
const btn = new BFSButton();

// will not trigger onUpdate call
// because the component is not in the DOM yet
btn.label = 'sample';

// will trigger onMount call
document.body.appendChild(btn)

// will trigger onUpdate call and DOM update
btn.label = 'another';
btn.setAttribute('label', 'another');

// will trigger onDestroy call
btn.remove()
</code-snippet>
