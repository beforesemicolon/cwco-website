<h2 id="contextprovidercomponent"><a href="#contextprovidercomponent">ContextProviderComponent</a></h2>
<p>The ContextProviderComponent class is a
   special <a href="https://github.com/beforesemicolon/cwco/blob/master/docs/WebComponent.md">WebComponent</a> class
   in a sense that it allows you to define the template right in your HTML file with it serving as the data provider for
   your template.</p>

<code-snippet language="js">
// in the browser
const {ContextProviderComponent} = window;

// in node
import {ContextProviderComponent} from "cwco";
</code-snippet>

<h3 id="mode"><a href="#mode">Mode</a></h3>
<p>By default, the ContextProviderComponent is in the <code>&quot;none&quot;</code> mode. Which means that its content can be easily
   target by CSS selectors of the document or in javascript DOM queries.</p>
<h3 id="template"><a href="#template">Template</a></h3>
<p>By default, the template is a single slot tag which means you don&#39;t need to define the component template inside the
   class.</p>
<p>You can define your data in the class...</p>

<code-snippet language="js">
// todo-app.js

class TodoApp extends ContextProviderComponent {
	app = {
		title: "Todo App",
		description: "My super cool todo app",
	}
}

TodoApp.register();
</code-snippet>

<p>...then set the content right in the HTML file and reference the data from the class.</p>

<code-snippet language="html">
<!-- index.html-->

<todo-app>
	<h1>{app.title}</h1>
	<p>{app.description</p>
</todo-app>
</code-snippet>

<h3 id="registration"><a href="#registration">Registration</a></h3>
<p>If you intend to define content in the HTML file, you MUST register the context provider component before all other components.</p>
<p>If you have multiple context provider component you must register them in the order you use them in the HTML file.</p>

<code-snippet language="html">
<theme-provider>
	<store-data-provider>
		<todo-app>
			<h1>{app.title}</h1>
			<p>{app.description</p>
		</todo-app>
	</store-data-provider>
</theme-provider>
</code-snippet>

<code-snippet language="js">
class ThemeProvider extends ContextProviderComponent {
	theme = {
		primary: "blue",
		secondary: "red",
	}
}

class StoreDataProvider extends ContextProviderComponent {
	store = {
		todos: [],
		user: {}
	}
}

class TodoApp extends ContextProviderComponent {
	app = {
		title: "Todo App",
		description: "My super cool todo app",
	}
}

// register them in the order you use them in the HTML file
ThemeProvider.register()
StoreDataProvider.register();
TodoApp.register();
</code-snippet>

<h3 id="the-slot-tag"><a href="#the-slot-tag">The slot tag</a></h3>
<p>What really makes the ContextProviderComponent special is how it handles the <code>slot</code> tag. It has a custom slot handler that gives
   it its superpowers. This means that no matter the component mode, the slot tag will be handled the same way which is
   not something you can do natively in HTML.</p>
<p>The template is a single slot tag, but you can also define your own template with slots where you wish. The only thing
   you need to keep in mind is that the slot is handled differently.</p>
<p>The example below renders the title and description inside and lets the rest of the app to be defined in the HTML file.</p>

<code-snippet language="js">
// todo-app.js

class TodoApp extends ContextProviderComponent {
	app = {
		title: "Todo App",
		description: "My super cool todo app",
		todos: []
	}
	
	onMount() {
		fetch('http://localhost:3000/api/todo')
			.then(res => res.json())
			.then(res => {
				this.app.todos = res.data;
			})
	}
	
	openTodo() {
		// handle opening todo
	}
	
	get template() {
		return `
			<h1>{app.title}</h1>
			<p>{app.description</p>
			<slot></slot>
		`;
	}
}

TodoApp.register();
</code-snippet>

<p>You can render the <code>todo-item</code> tag inside the <code>todo-app</code> tag and it will be placed where the slot tag is defined using
   the <a href="https://github.com/beforesemicolon/cwco/blob/master/docs/directives.md#repeat">repeat directive</a> to repeat
   for every <code>app.todos</code> array item.</p>

<code-snippet language="html">
<!-- index.html-->

<todo-app>
	<todo-item
		repeat="app.todos"
		name="$item.name"
		description="$item.description"
		status="$item.status"
		onclick="openTodo($item)"
	></todo-item>
</todo-app>
</code-snippet>

<h3 id="data-and-methods"><a href="#data-and-methods">Data and methods</a></h3>
<p>Any data defined inside the class can be accessed inside the template but not inside the custom components
   you create.</p>
<p>From the example above, the <code>app</code> object cannot be accessed inside the <code>todo-item</code> template. However, you can access
   the data and methods inside the <code>todo-item</code> tag body as this is still considered to be part of the provider template.</p>

<code-snippet language="html">
<!-- index.html-->

<todo-app>
	<todo-item
		repeat="app.todos"
		name="$item.name"
		description="$item.description"
		status="$item.status"
	>
		<!--
		 the todo-item tag has a slot for the button that handles
		 opening the single todo app
		-->
		<button onclick="openTodo($item)">open</button>
	</todo-item>
</todo-app>
</code-snippet>

<p>What this means is that, any HTML tag that is placed inside the body of the <code>todo-app</code> tag can access the
   ToDoApp class data and methods. Any HTML tag that belongs to other tags template will not. For those, you
   need to specify data as context.</p>
<h3 id="context"><a href="#context">Context</a></h3>
<p>ContextProviderComponent is like any other WebComponent and therefore, it may contain
	<a href="https://github.com/beforesemicolon/cwco/blob/master/docs/context.md">context data</a>.</p>
<p>This is the only way you can provide data inside the descendents component templates and it is excellent
   for data you want to share deeply for all components.</p>

<code-snippet language="js">
class ThemeProvider extends ContextProviderComponent {
	static initialContext = {
		theme: {
			colors: {
				primary: 'purple',
				secondary: '#222',
				cta: '#900',
				light: '#f2f2f2',
				dark: '#111',
			},
		}
	}
}
</code-snippet>

<p>Simply wrap your global data provider using context around the component tag, and it will be available
   deeply inside any component templates.</p>

<code-snippet language="html">
<todo-app>
	<theme-provider>
		<button
			type="button"
			attr.style="
				color: {theme.colors.light};
				background: {theme.colors.primary},
				true">click me</button>
	</theme-provider>
</todo-app>
</code-snippet>

<h3 id="styling"><a href="#styling">Styling</a></h3>
<p>By default, all context providers tag will be styled as display block. This can easily be overridden by defining
   your own stylesheet property.</p>
<p>Styling your context provider component is no different than styling any other WebComponent but because
   by default it does not use shadow root, you need to prefix every style with the <code>:host</code> to make sure
   the style does not affect things outside of its body.</p>
<p>This is due to the special way style tags are handled in <code>none</code> mode. You can
	<a href="https://github.com/beforesemicolon/cwco/blob/master/docs/stylesheet.md">Lear more about it here</a></p>

<code-snippet language="js">
class TodoApp extends ContextProviderComponent {
	// ...
	
	get stylesheet() {
		return `
			<style>
				:host h1 {
					color: [theme.colors.primary];
				}
			</style>
		`;
	}
	
	get template() {
		return `
			<h1>{app.title}</h1>
			<p>{app.description</p>
			<slot></slot>
		`;
	}
}
</code-snippet>

<p>One thing to know is that the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/::slotted">::slotted selector</a>
   will not work because the way the ContextProviderComponent handles the slot tags no matter what the mode
   of the component.</p>
