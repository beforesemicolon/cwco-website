<h2 id="configurations"><a href="#configurations"></a>Configurations</h2>
<p>The <code>WebComponent</code> class allows for very minimal configuration. These are mostly around the
   shadow root and HTML tag. Everything else must be explicitly set to be taken into consideration.</p>
<h3 id="tagname"><a href="#tagname"></a>tagName</h3>
<p>The tag name is defined by any of the following:</p>
<ul>
	<li>the name of the class;</li>
	<li>the value of the static <code>tagName</code> property;</li>
	<li>the name you provided when registering with the <code>register</code> call;</li>
</ul>
<h4 id="class-name"><a href="#class-name"></a>Class name</h4>
<p>When you define the class for your component you must use a combination of at least two words
   distinguished by casing (camel or pascal casing).
   Your class name is then taken and converted into HTML tags before trying to register it.</p>
<p>The tag name must be a <a href="https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name">valid tag name</a>
   according to rules defined by web standards.</p>

<code-snippet language="js">
class FlatList extends WebComponent {}
// becomes flat-list

class TodoItem extends WebComponent {}
// becomes todo-item

class BFSButton extends WebComponent {}
// becomes bfs-button
</code-snippet>

<p>If you try to access the <code>tagName</code> before you register the component, it will simply return
   an empty string unless you specified it inside the class.</p>

<code-snippet language="js">
class FlatList extends WebComponent {}

console.log(FlatList.tagName) // returns ''

FlatList.register();

console.log(FlatList.tagName) // returns 'flat-list'
</code-snippet>

<h5 id="tagname"><a href="#tagname"></a>tagName</h5>
<p>You may also use the static <code>tagName</code> inside your class definition. This option is particularly useful
   if you want to keep your class names simple and a custom tag name to match.</p>

<code-snippet language="js">
class Button extends WebComponent {
	static tagName = 'bfs-button';
}

class Todo extends WebComponent {
	static tagName = 'todo-item';
}
</code-snippet>

<p>Using this option to define the tag name gives you the advantage of <code>tagName</code> always being there.</p>

<code-snippet language="js">
class Button extends WebComponent {
	static tagName = 'bfs-button';
}

console.log(Button.tagName) // returns 'bfs-button'

FlatList.register();

console.log(Button.tagName) // returns 'bfs-button'
</code-snippet>

<h5 id="register"><a href="#register"></a>register</h5>
<p>The name of your tag can also be defined when you try to register your tag as a value for the <code>register</code> call.</p>

<code-snippet language="js">
class FlatList extends WebComponent {}

FlatList.register('flat-list');

console.log(FlatList.tagName) // returns 'flat-list'
</code-snippet>

<h3 id="mode"><a href="#mode"></a>mode</h3>
<p>The mode refers to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot/mode">shadow root mode</a>.</p>
<p><code>WebComponent</code> uses the same mode options plus an additional one:</p>
<ul>
	<li><strong>open</strong> (default): the Element <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/shadowRoot">shadowRoot</a> is accessible through Javascript from outside the class.</li>
	<li><strong>closed</strong>: the Element shadowRoot is inaccessible from outside the class via JavaScript.</li>
	<li><strong>none</strong>: the element inner HTML is not placed inside a shadow root. No shadow root is attached to the component.</li>
</ul>

<code-snippet language="js">
class TodoItem extends WebComponent {
	static mode = 'closed'; //
}
</code-snippet>

<p>You can access the shadow root via <code>root</code> and <code>shadowRoot</code> property in the instance of the element;</p>

<code-snippet language="js">
class TodoItem extends WebComponent {
	static mode = 'open';
}

const todo = new TodoItem();

// accessing the shadow root element
todo.root;
todo.shadowRoot;

document.body.appendChild(todo);
</code-snippet>

<h3 id="delegatesfocus"><a href="#delegatesfocus"></a>delegatesFocus</h3>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot/delegatesFocus">delegateFocus</a> options control s
   how the internal focus propagate to the host tag. It can be very useful to apply focus to the component tag when
   some internal element receives focus.</p>

<code-snippet language="js">
class SearchField extends WebComponent {
	static delegateFocus = true;
	
	get template() {
		return '<input type="search" style="outline: none">'
	}
}
</code-snippet>

<p>So instead of this:</p>

<code-snippet language="js">
class MyButton extends HTMLElement {
	constructor() {
		super();
	
		this.attachShadow({mode: 'closed', delegatesFocus: true});
	}
}

customElements.define('my-button', MyButton)
</code-snippet>

<p>You can do this:</p>

<code-snippet language="js">
class MyButton extends WebComponent {
	static mode = 'closed';
	static delegatesFocus = true;
}

MyButton.register();
</code-snippet>
